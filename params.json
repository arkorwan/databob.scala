{"name":"Databob.scala","tagline":"Randomised, zero-boilerplate object builders","body":"databob\r\n===========\r\n<a href=\"https://travis-ci.org/daviddenton/databob.scala\" target=\"_top\">\r\n<img src=\"https://travis-ci.org/daviddenton/databob.scala.svg\"/></a> \r\n<a href=\"https://coveralls.io/github/daviddenton/databob.scala?branch=master\" target=\"_top\"><img src=\"https://coveralls.io/repos/daviddenton/databob.scala/badge.svg?branch=master\"/></a> \r\n<a href=\"https://bintray.com/daviddenton/maven/databob/_latestVersion\" target=\"_top\"><img src=\"https://api.bintray.com/packages/daviddenton/maven/databob/images/download.svg\"/></a> \r\n<a href=\"https://bintray.com/daviddenton/maven/databob/view?source=watch\" target=\"_top\"><img src=\"https://www.bintray.com/docs/images/bintray_badge_color.png\"/></a> \r\n\r\nDatabob proves a way to generate completely randomised object builders with zero-boilerplate code.\r\n\r\n###Why?\r\nThe problem of generating dummy test instances for our classes has been around for a long time. Given the following case classes...\r\n```scala\r\ncase class EmailAddress(value: String)\r\n\r\ncase class Email(from: EmailAddress, to: Seq[EmailAddress], date: ZonedDateTime, read: Boolean, subject: String, readReceipt: Try[ReadReceipt])\r\n\r\ncase class Inbox(address: EmailAddress, emails: Seq[Email])\r\n```\r\n\r\nWe could start to write objects using the [TestBuilder](http://www.javacodegeeks.com/2013/06/builder-pattern-good-for-code-great-for-tests.html) pattern using the traditional method:\r\n```scala\r\nclass InboxAddressBuilder {\r\n  private var address = EmailAddress(\"some@email.address.com\")\r\n  private var emails = Seq[Email]()\r\n\r\n  def withAddress(newAddress: EmailAddress) = {\r\n    address = newAddress\r\n    this\r\n  }\r\n\r\n  def withEmails(newEmails: Seq[Email]) = {\r\n    emails = newEmails\r\n    this\r\n  }\r\n\r\n  def build = Inbox(address, emails)\r\n}\r\n```\r\n\r\nScala makes this easier for us somewhat by leveraging Case class ```copy()```. This also allows us to be compiler safe, as removing \r\na field will break the equivalent ```with``` method:\r\n```scala\r\nclass InboxAddressBuilder {\r\n  private var inbox = Inbox(EmailAddress(\"some@email.address.com\"), Seq[Email]())\r\n  \r\n  def withAddress(newAddress: EmailAddress) = {\r\n    inbox = inbox.copy(address = newAddress)\r\n    this\r\n  }\r\n\r\n  def withEmails(newEmails: Seq[Email]) = {\r\n    inbox = inbox.copy(emails = newEmails)\r\n    this\r\n  }\r\n\r\n  def build = inbox\r\n}\r\n\r\n```\r\n\r\nTaking this even further with default arguments, we can reduce this to:\r\n```scala\r\nobject InboxAddressBuilder {\r\n  def apply(address: EmailAddress = EmailAddress(\"some@email.address.com\"),\r\n            emails: Seq[Email] = Nil)\r\n    = Inbox(address, emails)\r\n}\r\n```\r\n\r\nSo, better - but it still seems pretty tedious to maintain. Additionally, we don't really want tests to rely unknowingly on \r\nbits of default test data for multiple tests which will lead to an explosion of [ObjectMother](http://martinfowler.com/bliki/ObjectMother.html)-type methods with small variations \r\nto suit particular tests.\r\n\r\nWhat we really want are completely randomised instances, with important overrides set-up only for tests that rely on them. No sharing of test data across tests. Ever.\r\n\r\nEnter Databob. For a completely randomised instance, including non-primitive sub-tree objects:\r\n```scala\r\nDatabob.random[Email]\r\n```\r\n\r\nThat's it. Want to override particular value(s)?\r\n```scala\r\nDatabob.random[Inbox].copy(address = EmailAddress(\"my@real.email.com\")\r\n```\r\n\r\nOr add your own rule for generating values:\r\n```scala\r\nimplicit val generators = typeIs(databob => {\r\n  EmailAddress(databob.mk[String] + \"@\" + databob.mk[String] + \".com\")\r\n}) +: Generators.EmptyGenerators\r\nDatabob.random[Email]\r\n```\r\n\r\nOut of the box, Databob supports:\r\n- Nested object-trees (ie. non-primitive fields)\r\n- All Scala/Java primitives: Default, random\r\n- Scala and Java Collection classes: Empty, single-value, variable size, random)\r\n- Java8 date-time values: Epoch, current-time, random\r\n- Some monadic types (Option/Either/Try/Future): Happy, Unhappy, random\r\n- Simple overriding mechanism for your own-types and custom generation rules\r\n\r\n###See it in action\r\nSee the [example code](https://github.com/daviddenton/databob.scala/tree/master/src/test/scala/databob/examples).\r\n\r\n###Get it\r\nAdd the following lines to ```build.sbt```:\r\n```scala\r\nresolvers += \"JCenter\" at \"https://jcenter.bintray.com\"\r\nlibraryDependencies += \"io.github.daviddenton\" %% \"databob.scala\" % \"X.X.X\"\r\n```\r\n\r\n###Acks\r\nTo [Json4S](https://github.com/json4s/json4s) for the inspiration and reflection utils.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}